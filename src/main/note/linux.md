
### CPU篇
#### 1. 平均负载
了解系统负载命令：uptime, top
单位时间内可运行状态和不可中断状态的平均进程数，也就是平均活跃进程
   (当load average=2时如果在1个CPU的系统则一半的进程竞争不到资源.所以负载可以客观的判定一个机器当下的性能如何)
运行状态(R)：
不可中断状态(D)：如等待硬件设备的I/O响应，它也是对进程和硬件设备的一种保护机制
负载超过70%的时候就可以排查了即 4*0.7=2.8

load & CPU使用率  
1. CPU密集型进程 两者都会高 ，此时说明系统计算等频繁  
2. I/O密集 负载高但CPU不一定(此时CPU在等待I/O的读写) ， 网络IO，数据库IO等 
3. 大量进程 ，系统请求很多
在机器负载高的情况下 查找原因可能是CPU计算高(cpu高io低) 进程多 IO密集 同时要pidstat排查


#### 2. 上下文切换
线程在竞争CPU的时候并没有真正的运行为什么还会导致系统负载的升高？！！！
CPU寄存器， CPU内部容量小但速度快，为了快速运行任务而设计的
程序计数器，存储CPU正在执行的指令位置，或即将执行的下一条指令位置
上下文切换：把当前线程运行数据保存在系统内核 加载新任务的上下文到寄存器和程序计数器
所以上下文切换也就是更换了寄存器的值导致负载升高的原因？==
a 进程上下文切换：
	进程由内核调度的 切换只能发生在内核态 所以进程的切换不仅包括了虚拟内存，栈，全局变量等用户空间资源还内核堆栈，寄存器等内核空间。CPU将耗费在这些资源的保存和回复上
> 1. 时间片耗尽 
> 2. 系统资源不足  
> 3. sleep主动挂起  
> 4. 更高优先级的抢断  
> 5. 硬件中断时 转而执行内核的中断程序
系统调用 发生两次CPU上下文切换
b.线程上下文切换：过程？？？
	线程是调度的基本单位; 多个线程之间会共享虚拟内存和全局变量(堆？方法区)等资源； 线程也有自己的私有区域如寄存器，栈等
	所以线程之间的切换只需要切换线程的私有数据，寄存器等不共享数据 相对于进程来说更少的资源 但也是负载增高的一部分
	较少切花：1.无锁变成  2.CAS也不需加锁  3.使用最少的线程
c.中断上下文切换：
	不涉及进程的用户态
	无需涉及资源的保存和恢复
 
 
#### 3. CPU达到100%怎么办
CPU使用率 = 1- 空闲时间/总CPU时间
节拍率 控制LinuxCPU切换的时间片
top / ps
1.perf top--> 找到具体的函数
2.top us显示CPU使用率很高但是每个进程的却很少 --> 直接调用了其他二进制程序；应用本身在不断的奔溃重启


#### 4. 僵尸进程 & 不可中断线程
进程状态：R(Running), D(不可中断睡眠一般指的是和硬件交互), Z(僵尸进程实际已经结束但还未回收), S(可中断睡眠 挂起), I(空闲状态)


#### 5. 软中断 & 硬中断
以网络接受数据为例, 网卡数据读到内存 --> 更新硬件寄存器状态 --> 发送软中断信号通知下一步处理
处理硬件请求就是硬中断，快速执行
由内核触发即软请求，延迟执行。 ksoftirqd/CPU 编号
/proc/softirqs  软中断  -- 网络收发，定时，调度，RCU锁； 频繁的软中断同样是CPU升高因素
/proc/interrupts  硬中断  


#### 6. 快速分析系统CPU的瓶颈
  CPU性能指标：
     CPU使用率(用户CPU,系统CPU,iowait,软硬中断)，
     平均负载， uptime
	 上下文切换(自愿和非自愿)--消耗在寄存器,内核栈，虚拟内存等的数据保存和切换上
	 CPU缓存命中率，
	
#### 7. CPU性能优化  
   
   
### 内存篇
> 内存映射：Linux给每个进程分配了独立连续的虚拟地址空间。内存映射就是将虚拟内存映射到物理内存
> 中断异常：brk()/mmap()之后不会立即分配内存而是通过缺页中断
   

#### 1. buffer & cache
> buffer: 内核缓冲区用到的内存。对原始磁盘块的临时存储就是用来缓存磁盘数据。这样内核就可以把分散的数据缓存起来统一进行写入
> cache: 内核页缓存和Slab用到的内存。从磁盘读取文件页的缓存 这样下次就可以直接从内存中读取而不需要磁盘

#### 2. 内存泄漏
dump文件收集的两种方式
> 1. 设置启动的JVM参数 `-XX:+HeapDumpOnOutOfMemoryError, -XX:HeapDumpPath=/opt/jvmdump` 每次内存溢出时会自动将堆转储
> 2. jmap:jmap -dump:live,format=b,file=/opt/jvm/dump.hprof pid

#### 3. Swap
文件页,如缓存和缓冲就属于可回收内存他们在内存管理中通常被叫做文件页
脏页,而那些被修改过且暂时还没写入磁盘的数据就称为脏页这些数据得先写入内存然后才能释放
内存回收
1. 直接内存回收 如缓存
2. 内核线程定时回收即kswapd0. 水位分为页最小阈值，页低阈值，页高阈值。一旦小于页低阈值则开始回收
匿名页 如果这些资源很少被利用了就可以swap到磁盘上，需要的时候再从磁盘换回到内存
NUMA(Non-Uniform Memory Access):
  
  
#### 4. 快准狠找到系统内存问题
内存性能指标
1. 已用内存，剩余内存，共享内存，可用内存，缓存和缓冲区；
2. 虚拟内存，常驻内存，共享内存以及Swap内存；
3. 缺页异常：导致的频繁I/O，内存访问也会慢很多
   
   
### 磁盘和文件系统
Linux中一切皆文件 不仅是普通的文件和目录就连块设备，套字节，管道等也都要通过统一的文件系统来管理
虚拟文件系统(VFS)定义了一组所有文件系统都支持的数据结构和标准接口。这样用户进程和内核进程中的其他子系统就只需要跟VFS提供的统一借口而进行交互
文件 = 索引节点(记录文件的元数据,唯一标识) + 目录项(维护树状结构)


---
### 四大模块解决方案
#### CPU高
pidstat -u查看cpu高的pid


#### 内存高


#### 磁盘I/O


#### 网络性能
  
  
---

### 命令
grep 'model name' /proc/cpuinfo | wc -l  

查看线程运行数据命令pidstat
pidstat -u 5 1   --> 5s后输出一组数据 ...%cpu 
	-u：默认的参数，显示各个进程的cpu使用统计
	-r：显示各个进程的内存使用统计
	-d：显示各个进程的IO使用情况
	-p：指定进程号
	-w：显示每个进程的上下文切换情况
	-t：显示选择任务的线程的统计信息外的额外信息

	%usr：进程在用户空间占用cpu的百分比
	%system：进程在内核空间占用cpu的百分比
	%guest：进程在虚拟机占用cpu的百分比
	%CPU：进程占用cpu的百分比

查看系统cpu,io等使用率
mpstat -P ALL 5    --> ...%sys, %iowait
stress -c 8 --timeout 600

vmstat 1 10   -- 了解上上下文切换
	cs 每秒切换次数
	in 每秒中断次数
	r 就绪队列长度 正在运行和等待CPU的进程数
	b 不可中断进程数
 
pidstat -w 
	cswch 每秒自愿上下文切花
	nvcswch 非自愿

查看排查线上CPU使用情况
只保留各个 CPU 的数据
`
$ cat /proc/stat | grep ^cpu
cpu  280580 7407 286084 172900810 83602 0 583 0 0 0
cpu0 144745 4181 176701 86423902 52076 0 301 0 0 0
cpu1 135834 3226 109383 86476907 31525 0 282 0 0 0
	user(us)  用户态CPU时间
	nice(ni)  低优先级用户态CPU
	system(sys)   内核态CPU时间
	idle(id)	 空闲时间
	iowait(wa)   1/O等待时间
	irq(hi)		硬中断的CPU时间
	softirqs(si)   软中断CPU时间	
	steal(st)
	guest(guest)   运行虚拟机CPU时间
	guest_nice
`
top 
perf top 
	overhead  比例
	Shared	动态共享对象如内核，进程名
	Object	对象类型
	Symbol	符号名 函数名
	
-g 开启调用关系分析，-p 指定 php-fpm 的进程号 21515
$ perf top -g -p 21515
记录性能事件，等待大约 15 秒后按 Ctrl+C 退出
$ perf record -g
查看报告
$ perf report

内核参数：
ulimit -a




