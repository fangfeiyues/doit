
#### 1.如何做到缓存(如redis)与DB里的数据一致性  
1. 更新和删除的时候防止 先删除DB在删除缓存时失败造成的不一致及先删除缓存再删DB时可能重新加载到缓存
2. 维护一个安全队列存放删除的数据。先删除缓存再放入队列，当发现删除的数据还在队列时即阻塞请求等待等待DB删除成功返回删除队列唤醒请求
  
#### 2.什么是缓存系统，如何设计的


#### 3.如何防止缓存击穿和雪崩 热key问题

1. 缓存穿透: 防止大量无效的key如-1或过大的值直接请求DB，导致DB的压力过大
> 1. 布隆过滤器，快速查看是否存在key
> 2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）
> 3. 限流。滑动窗口，令牌桶算法和漏桶算法

2. 缓存击穿: 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），
这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力
> 1. 设置热点数据永远不过期
> 2. 加互斥锁 -- 限流
> 3. 对于部分热点数据 进行缓存预热
 
3. 缓存雪崩: 缓存雪崩是指缓存中数据大**批量到过期时间**，而查询数据量巨大，引起数据库压力过大
(和缓存击穿不同的是: 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了很多数据都查不到从而查数据库)
> 1. 加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上
> 2. 失效时间基础上增加一个随机值
> 3. 设置热点数据永远不过期
         
4. 热key


#### 4.缓存数据过期后的更新如何设计
如上


#### 5.Redis的数据结构都有哪些
1. string: 预分配冗余空间的方式来减少内存的频繁分配；当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间
2. list: 链表，快速链表即将多个ziplist连起来达到节省内存空间作用同时减少了双向指针
3. set: 保证key值的唯一性
4. hash: key -name -age
5. zset: 跳表减少早链表的情况下查询的时间复杂度


#### 6.Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等
持久化
> 1. 快照 可根据设置 save 900 1 (900s内有一条写入就触发一次快照)
> 2. AOF  appendonly yes (开启aof) 同步方式也可以选择 always, everysec, no(交给OS处理)
> 原理1: bgsave会 fork子进程执行RDB操作，注意fork操作会阻塞
> 原理2: fork 子进程进行重写操作其中主进程依旧相应操作,并把数据同时放入aof_buffer及 aof_rewrite_buffer, 这样子进程会吧重新期间的变化也写入新的AOF文件
> https://segmentfault.com/a/1190000015983518

内存设置 
    1.maxmemory
    2.maxmemory_policy 过期策略
        volatile-lru：使用LRU算法从已设置过期时间的数据集合中淘汰数据。
        volatile-ttl：从已设置过期时间的数据集合中挑选即将过期的数据淘汰。    
        volatile-random：从已设置过期时间的数据集合中随机挑选数据淘汰。   
        allkeys-lru：使用LRU算法从所有数据集合中淘汰数据，淘汰使用频率最少的key。
        allkeys-random：从数据集合中任意选择数据淘汰
        no-enviction：禁止淘汰数据
        
集群的应用和优劣势

淘汰策略
  1. 定时遍历字典到期的key
     贪心策略：从过期字典中随机 20 个 key - 删除这 20 个 key 中已经过期的 key - 如果过期的 key 比率超过 1/4，那就重复步骤
  2. 惰性策略删除 即客户端访问key检查过期了马上删除
从库不会进行过期扫描，从库对过期的处理是被动的。在 AOF 文件里增加一条 del 指令


#### 7.redis2和redis3的区别，redis3内部通讯机制。



#### 8.当前redis集群有哪些玩法，各自优缺点，场景。



#### 9.Memcache的原理，哪些数据适合放在缓存中。



#### 10.redis和memcached 的内存管理的区别。



#### 11.Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。
> 1. redis 的 setnx 实现内置的锁
> 2. 乐观锁（redis 的命令 watch）


#### 12.Redis的选举算法和流程是怎样的。
1. configuration epoch计数器增加1
2. 源sentinel向目标sentinel发送
   SENTINEL is-master-down-by-addr <ip> <port> <current epoch> <runid>
  命令返回leader_runid和leader_epoch参数记录目标sentinel的局部领头运行ID和配置纪元
3. 获取半数以上的即将成为领头
故障转移：


#### 13.redis的持久化的机制，aof和rdb的区别。
RDB，全量快照。redis使用操作系统的COW(Copy On Write)实现快照持久化，
    glibc的函数fork一个子进程快照持久化由子进程完成，父进程继续处理客户端请求。两者共享内存所以子父进程分离的瞬间内存几乎没变化
    当客户端持续操作的时候，父进程会在原来的内存数据中复制出一份共享页面操作此时子进程持久化的数据保持不变。同时越来越多的共享页面被分离出来，内存就会持续增长
AOF，连续增量备份。先执行命令再存盘因为redis都是在内存操作。
    瘦身：bgrewriteaof指令    

fsync：Redis 通常是每隔 1s 左右执行一次 fsync 操作 将指定文件的内容强制从内核缓存刷到磁盘 保证宕机不丢失
快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。

遍历整个内存，大块写磁盘会加重系统负载
AOF 的 fsync 是一个耗时的 IO 操作，它会降低 Redis 性能，同时也会增加系统 IO 负担
所以通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。
但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是在网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，
所以在生产环境要做好实时监控工作，保证网络畅通或者能快速修复。
另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失
https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5afc364c6fb9a07aaf3567c8

#### 14.redis的集群怎么同步的数据的。


#### 15.知道哪些redis的优化操作 ???


#### 16.Reids的主从复制机制原理。
CPA原理：Consistent一致性， Availability 可用性， Partition tolerance分区容忍性
> 增量同步：维护一个buffer定长的环形数组,主节点将自己状态作出修改的指令记录在buffer然后异步同步到从节点，如果数组满了就会从头开始覆盖
> 快照同步：Master快照数据到磁盘，将磁盘文件同步给Slaver。
        在整个的快照过程中增量buffer还是在继续的如果快照时间太长或buffer太小 会导致同步期间的增量指令在复制 buffer 中被覆盖


#### 17.Redis的线程模型是什么。
单线程模型
> 1.redis所有数据都存在内存中所以运行速度快
> 2.多路复用，select轮询事件API，非阻塞IO等连接大量的并发客户端


#### 18.请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。


#### 19.如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。


#### 20.本地缓存在并发使用时的注意事项。


#### redis锁
  1.set lock:codehole true ex 5 nx； 解决在setnx和expire之间非原子性的问题
      SET key random_value NX PX 30000； random_value这里的随机字符串很有必要，NX主要防止覆盖之前的key导致无法上锁
      客户端1获取锁成功。
      客户端1在某个操作上阻塞了很长时间。
      过期时间到了，锁自动释放了。
      客户端2获取到了对应同一个资源的锁。
      客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。
  2.可重入性
  3.分布式下主节点挂了但同步时没能把锁同步到从节点可能的导致加两把锁 Redlock算法
    加锁时，它会向过半节点发送 set(key, value, nx=True, ex=xxx) 指令，只要过半节点 set 成功，那就认为加锁成功。释放锁时，需要向所有节点发送 del 指令