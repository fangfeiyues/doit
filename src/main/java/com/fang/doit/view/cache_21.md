
#### 1.如何做到缓存(如redis)与DB里的数据一致性
  https://my.oschina.net/jiagouzhan/blog/2990423
  https://mp.weixin.qq.com/s/n-8-YtUls-fHTQ2nFyLNew
初级数据不一致：先删除缓存，再删数据库。保证在数据库回写的时候失败导致缓存依旧是旧数据
高级并发不一致：变更时先删缓存但同时请求过来读到原来旧数据库数据放到缓存：
   删除缓存后 “变更库数据”操作放到队列
   如果此时求过来读到缓存空后会“读取库数据，回写缓存”，读放入同一个队列
   队列积压
  
#### 2.什么是缓存系统，如何设计的


#### 3.如何防止缓存击穿和雪崩


#### 4.缓存数据过期后的更新如何设计


#### 5.Redis的数据结构都有哪些


#### 6.Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等
持久化方式  1.RDB快照
内存设置
集群
淘汰策略

#### 7.redis2和redis3的区别，redis3内部通讯机制。


#### 8.当前redis集群有哪些玩法，各自优缺点，场景。


#### 9.Memcache的原理，哪些数据适合放在缓存中。


#### 10.redis和memcached 的内存管理的区别。


#### 11.Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。
1.redis 的 setnx 实现内置的锁
2.乐观锁（redis 的命令 watch）

#### 12.Redis的选举算法和流程是怎样的。
1.configuration epoch计数器增加1
2.源sentinel向目标sentinel发送
   SENTINEL is-master-down-by-addr <ip> <port> <current epoch> <runid>
  命令返回leader_runid和leader_epoch参数记录目标sentinel的局部领头运行ID和配置纪元
3.获取半数以上的即将成为领头
故障转移：


#### 13.redis的持久化的机制，aof和rdb的区别。
RDB，全量快照。redis使用操作系统的COW(Copy On Write)实现快照持久化，
    glibc的函数fork一个子进程快照持久化由子进程完成，父进程继续处理客户端请求。两者共享内存所以子父进程分离的瞬间内存几乎没变化
    当客户端持续操作的时候，父进程会在原来的内存数据中复制出一份共享页面操作此时子进程持久化的数据保持不变。同时越来越多的共享页面被分离出来，内存就会持续增长
AOF，连续增量备份。先执行命令再存盘因为redis都是在内存操作。
    瘦身：bgrewriteaof指令    

fsync：Redis 通常是每隔 1s 左右执行一次 fsync 操作 将指定文件的内容强制从内核缓存刷到磁盘 保证宕机不丢失
快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。

遍历整个内存，大块写磁盘会加重系统负载
AOF 的 fsync 是一个耗时的 IO 操作，它会降低 Redis 性能，同时也会增加系统 IO 负担
所以通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。
但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是在网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，
所以在生产环境要做好实时监控工作，保证网络畅通或者能快速修复。
另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失
https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5afc364c6fb9a07aaf3567c8

#### 14.redis的集群怎么同步的数据的。


#### 15.知道哪些redis的优化操作 ???


#### 16.Reids的主从复制机制原理。
CPA原理：Consistent一致性， Availability 可用性， Partition tolerance分区容忍性
增量同步：维护一个buffer定长的环形数组如果数组满了就会从头开始覆盖
快照同步：Master快照数据到磁盘，将磁盘文件同步给Slaver。
        在整个的快照过程中增量buffer还是在继续的如果快照时间太长或buffer太小 会导致同步期间的增量指令在复制 buffer 中被覆盖


#### 17.Redis的线程模型是什么。
单线程模型
1.redis所有数据都存在内存中所以运行速度快
2.多路复用，select轮询事件API，非阻塞IO等连接大量的并发客户端


#### 18.请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。


#### 19.如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。


#### 20.本地缓存在并发使用时的注意事项。

#### redis锁
  1.set lock:codehole true ex 5 nx； 解决在setnx和expire之间非原子性的问题
      SET key random_value NX PX 30000； random_value这里的随机字符串很有必要，NX主要防止覆盖之前的key导致无法上锁
      客户端1获取锁成功。
      客户端1在某个操作上阻塞了很长时间。
      过期时间到了，锁自动释放了。
      客户端2获取到了对应同一个资源的锁。
      客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。
  2.可重入性
  3.分布式下主节点挂了但同步时没能把锁同步到从节点可能的导致加两把锁 Redlock算法
    加锁时，它会向过半节点发送 set(key, value, nx=True, ex=xxx) 指令，只要过半节点 set 成功，那就认为加锁成功。释放锁时，需要向所有节点发送 del 指令