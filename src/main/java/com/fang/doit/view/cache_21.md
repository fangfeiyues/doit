
#### 1.redis和memcached 的内存管理的区别。


#### 2.Redis的数据结构都有哪些
> 1.string: 预分配冗余空间的方式来减少内存的频繁分配；当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间
> 2.list: 链表，快速链表即将多个ziplist连起来达到节省内存空间作用同时减少了双向指针
> 3.set: 保证key值的唯一性
> 4.hash: key -name -age
> 5.zset: 跳表减少早链表的情况下查询的时间复杂度

#### 3.Redis缓存淘汰策略
> 1.不淘汰. 数据写满了新的请求拒绝
> 2.设置过期时间键值对. 随机删除；按照过期时间删除；lru最近最少访问淘汰策略；lfu最小访问频率淘汰
> 3.所有键值对. 随机删除；lru最近最少访问淘汰策略；lfu最小访问频率淘汰


#### 4.redis的持久化的机制
RDB，全量快照。redis使用操作系统的COW(Copy On Write)实现快照持久化，
    glibc的函数fork一个子进程快照持久化由子进程完成，父进程继续处理客户端请求。两者共享内存所以子父进程分离的瞬间内存几乎没变化
    当客户端持续操作的时候，父进程会在原来的内存数据中复制出一份共享页面操作此时子进程持久化的数据保持不变。同时越来越多的共享页面被分离出来，内存就会持续增长
AOF，连续增量备份。先执行命令再存盘因为redis都是在内存操作。
    瘦身：bgrewriteaof指令    

fsync：Redis 通常是每隔 1s 左右执行一次 fsync 操作 将指定文件的内容强制从内核缓存刷到磁盘 保证宕机不丢失
快照是通过开启子进程的方式进行的，它是一个比较耗资源的操作。

遍历整个内存，大块写磁盘会加重系统负载
AOF 的 fsync 是一个耗时的 IO 操作，它会降低 Redis 性能，同时也会增加系统 IO 负担
所以通常 Redis 的主节点是不会进行持久化操作，持久化操作主要在从节点进行。从节点是备份节点，没有来自客户端请求的压力，它的操作系统资源往往比较充沛。
但是如果出现网络分区，从节点长期连不上主节点，就会出现数据不一致的问题，特别是在网络分区出现的情况下又不小心主节点宕机了，那么数据就会丢失，
所以在生产环境要做好实时监控工作，保证网络畅通或者能快速修复。
另外还应该再增加一个从节点以降低网络分区的概率，只要有一个从节点数据同步正常，数据也就不会轻易丢失
https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5afc364c6fb9a07aaf3567c8


#### 5.如何做到缓存(如redis)与DB里的数据一致性  -- 2021.04.08 
> 1.更新和删除的时候防止 先删除DB在删除缓存时失败造成的不一致及先删除缓存再删DB时可能重新加载到缓存
> 2.维护一个安全队列存放删除的数据。先删除缓存再放入队列，当发现删除的数据还在队列时即阻塞请求等待等待DB删除成功返回删除队列唤醒请求
> 同时在更新的时候先更新DB在删除缓存，而不是直接更新缓存数据以来避免一些冷数据被频繁的操作 

#### 6.如何防止缓存击穿和雪崩 热key问题 -- 2021.04.08

1.缓存穿透: 防止大量无效的key如-1或过大的值直接请求DB，导致DB的压力过大
> 1.布隆过滤器，快速查看是否存在key
> 2.从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）
> 3.限流。滑动窗口，令牌桶算法和漏桶算法

2. 缓存击穿: 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），
这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力
> 1.加互斥锁 (限流，降级)
> 2.对于部分热点数据 进行缓存预热
> 
 
3. 缓存雪崩: 缓存雪崩是指缓存中数据大**批量到过期时间**，而查询数据量巨大，引起数据库压力过大
(和缓存击穿不同的是: 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了很多数据都查不到从而查数据库)
> 1.加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上
> 2.失效时间基础上增加一个随机值
> 3.设置热点数据永远不过期
         
4. 热key

#### 7.设计一个可以控制缓存总体大小的自动适应的本地缓存



#### 8.Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。
> 1. redis 的 setnx 实现内置的锁
> 2. 乐观锁（redis 的命令 watch）




#### 9.Redis的线程模型是什么。-- 2021.04.09
单线程模型
> 1.数据保存在内存中. 读写操作只需要访问内存不需要磁盘IO
> 2.底层数据结构. Redis以Key-value的格式存储在散列表中时间复杂度O(1)同时定义了丰富的数据结构就可根据value选择特性
> 3.单线程模型
> 4.多路复用. 


#### 10.Redis多路复用实现



#### 11.redis锁 -- 2021.04.09
  1.set lock:codehole true ex 5 nx； 解决在setnx和expire之间非原子性的问题
      SET key random_value NX PX 30000； random_value这里的随机字符串很有必要，NX主要防止覆盖之前的key导致无法上锁
      客户端1获取锁成功。
      客户端1在某个操作上阻塞了很长时间。
      过期时间到了，锁自动释放了。
      客户端2获取到了对应同一个资源的锁。
      客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。
  2.可重入性
  3.分布式下主节点挂了但同步时没能把锁同步到从节点可能的导致加两把锁 Redlock算法
    加锁时，它会向过半节点发送 set(key, value, nx=True, ex=xxx) 指令，只要过半节点 set 成功，那就认为加锁成功。释放锁时，需要向所有节点发送 del 指令
    
#### 12.分布式锁会遇到哪些问题



#### 13.Redis的选举算法和流程是怎样的。 -- 2021.04.09
1. configuration epoch计数器增加1
2. 源sentinel向目标sentinel发送
   SENTINEL is-master-down-by-addr <ip> <port> <current epoch> <runid>
  命令返回leader_runid和leader_epoch参数记录目标sentinel的局部领头运行ID和配置纪元
3. 获取半数以上的即将成为领头
故障转移：


#### 14.Redis的主从复制机制原理
CPA原理：Consistent 一致性， Availability 可用性， Partition tolerance 分区容忍性
> 增量同步：维护一个buffer定长的环形数组,主节点将自己状态作出修改的指令记录在buffer然后异步同步到从节点，如果数组满了就会从头开始覆盖
> 快照同步：Master快照数据到磁盘，将磁盘文件同步给Slaver。
        在整个的快照过程中增量buffer还是在继续的如果快照时间太长或buffer太小 会导致同步期间的增量指令在复制 buffer 中被覆盖

#### 15.GuavaCache本地缓存实现机制


#### 16.设计一个缓存失效策略，想到了线程定时check








